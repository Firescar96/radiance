#ifndef CFGOBJ 
#error "CFGOBJ not defined in config_gen.c"
#endif

// Instance of global configuration object
// Each value is initialized with its default value
struct CFGOBJ CFGOBJ = {
    #define CFGSECTION(w, d...) .w = { d },
    #define CFGSECTION_LIST(w, max, d) .LIST_NAME(w) = {{.configured = 0}}, .LIST_N_NAME(w) = 0,
    #define CFG(n, type, default) .n = default,
    #define CFG_LIST(name, max, type) .LIST_N_NAME(name) = 0, .LIST_NAME(name) = {0}, 
    #include CFGOBJ_PATH
};

// Function to parse line of configuration file
// Called from CFGOBJ_load
static int CONCAT(CFGOBJ, _parse)(void * user, const char * section, const char * key, const char * value){
    struct CFGOBJ * cfg = (struct CFGOBJ *) user;
    #define CFGSECTION(s, d) if(strcasecmp(section, STRINGIFY(s)) == 0){ struct SECTIONSTRUCT(s) * sp = &cfg->s; d return 0;}
    #define CFGSECTION_LIST(name, max, d) \
        if(strncasecmp(section, LIST_PREFIX(name), strlen(LIST_PREFIX(name))) == 0){ \
            int i = atoi(section + strlen(LIST_PREFIX(name))); \
            if(i >= max || i < 0){  \
                ERROR("invalid " STRINGIFY(name) " entry! (%d, max is %d)\n", i, max); \
                return 0; \
            } \
            if(!cfg->LIST_NAME(name)[i].configured){ \
                cfg->LIST_NAME(name)[i].configured = 1; \
                cfg->LIST_N_NAME(name)++; \
            } \
            struct SECTIONSTRUCT(name) * sp = &cfg->LIST_NAME(name)[i]; \
            d \
            return 0; \
        }
    #define CFG(n, type, default) if(strcasecmp(key, STRINGIFY(n))==0){ sp->n = type##_FN(value); return 1;} 
    #define CFG_LIST(n, max, type) \
        if(strncasecmp(key, LIST_PREFIX(n), strlen(LIST_PREFIX(n))) == 0){ \
            if(sp->LIST_N_NAME(n) >= max){ \
                ERROR("too many " STRINGIFY(n) " entries! (max is %d)\n", max); \
                return 0; \
            } \
            int idx = atoi(key + strlen(LIST_PREFIX(n))); \
            if(idx < 0) { \
                ERROR("Negative index: %s\n", key); \
                return 0; \
            } \
            int j = sp->LIST_N_NAME(n)++; \
            sp->LIST_NAME(n)[j].index = idx; \
            sp->LIST_NAME(n)[j].n = type##_FN(value); \
            return 1; \
        } 
    #include CFGOBJ_PATH
    return 0;
}

// Function to dump out a configuration to a file
int CONCAT(CFGOBJ, _dump)(struct CFGOBJ * cfg, const char * filename){
    FILE * stream = fopen(filename, "w");
    if(!stream)
        return 1;

    #define CFGSECTION(s, d) fprintf(stream, "[" #s "]\n"); if(1){ struct SECTIONSTRUCT(s) * sp = &cfg->s; d; } fprintf(stream, "\n");
    #define CFGSECTION_LIST(name, max, d) \
        for(int i = 0; i < max; i++){ \
            if(!cfg->LIST_NAME(name)[i].configured) continue; \
            struct SECTIONSTRUCT(name) * sp = &cfg->LIST_NAME(name)[i]; \
            fprintf(stream, "[" LIST_PREFIX(name) "%d]\n", i); \
            d \
            fprintf(stream, "\n"); \
        } 
    #define CFG(n, type, default) fprintf(stream, STRINGIFY(n) "="); fprintf(stream, type##_FMT(sp->n)); fprintf(stream, "\n");
    #define CFG_LIST(name, max, type) \
        for(int j = 0; j < sp->LIST_N_NAME(name); j++) { \
            fprintf(stream, LIST_PREFIX(name) "%d=", sp->LIST_NAME(name)[j].index); \
            fprintf(stream, type##_FMT(sp->LIST_NAME(name)[j].name)); \
            fprintf(stream, "\n"); \
        }
    #include CFGOBJ_PATH

    fclose(stream);

    return 0;
}

// Function to load in a configuration file
int CONCAT(CFGOBJ, _load)(struct CFGOBJ * cfg, const char * filename){
    if(ini_parse(filename, CONCAT(CFGOBJ, _parse), cfg) < 0){
        printf("Unable to load " STRINGIFY(CFGOBJ) " configuration file: '%s'\n", filename);
        return 1;
    }
    printf("Loaded " STRINGIFY(CFGOBJ) " configuration file: '%s'\n", filename);
    return 0;
}
